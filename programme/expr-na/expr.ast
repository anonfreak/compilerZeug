/* Project:  COCKTAIL training
 * Descr:    Build an Abstract Syntax Tree for an expression language
 * Kind:     AST specification
 * Author:   Prof. Dr. Juergen Vollmer <vollmer@dhbw-karlsruhe.de>
 * $Id: expr.ast.in,v 1.11 2010/05/20 20:47:35 vollmer Exp $
 */
MODULE abstract_syntax

/* Exercises
 *  - Extend the AST specification in expr.ast to represent the language
 *    constructs defined in expr.pars
 */
TREE   Tree

EXPORT {
  # include "Position.h"
  # include "Idents.h"

  # define FATAL_ERROR() 								      \
  {fprintf (stderr, "***** FATAL ERROR *****: file %s, line %d\n", __FILE__ , __LINE__); abort(); }
  /* Indicate a programming error
   * __FILE__  the filename of the source file "calling" the macro
   * __LINE__  the line "calling" this macro
   */

  typedef enum {
     void_type
   , int_type
   , float_type
   , bool_type
  } tTYPE;

 extern const char *type2string (tTYPE typ);
/* mapping from a tTYPE value to a string */

/* The following is used by files generated by the AST tool as part of the generated interface */
/* output of an type `typ' to `file' */
 # define fprintf_tTYPE(file, typ)  fprintf (file, "%s", type2string(typ));

 /* `writeTYPE(val)' is used by the generated AST routines to print a textual
  * representation of a value of the user defined type TYPE.
  * The output is written to file `yyf' (a global FILE* variable set somewhere)
  */
 # define writetTYPE(val) fprintf_tTYPE (yyf, val);
} // EXPORT

GLOBAL {
 const char *type2string (tTYPE typ)
 {
   switch (typ) {
   case void_type:
	return "<void>";
   case int_type:
	return "INT";
   case float_type:
	return "FLOAT";
   case bool_type:
	return "BOOL";
   default:
	FATAL_ERROR ();
	return "";
   }
 }
} // GLOBAL

PROPERTY INPUT

RULE

DECLS = <
  no_decl 	=
		.
  DECL		= Next: DECLS REV
 	          [Pos: tPosition]
		  [Ident: tIdent]
		  [Type:  tTYPE] <
    var_decl    =
		.
    param_decl  =
		.
    func_decl   = Parameter: DECLS
		  Local:     DECLS
		  Body:      STMTS
		.
    > . // DECL
> . // DECLS

STMTS = <
  no_stmt =
	  .
  STMT 	  = Next: STMTS REV
            [Pos: tPosition] <
    assign_stmt = Lhs: EXPR
		  Rhs: EXPR
		.
    if_stmt     = Cond: EXPR
		  Then: STMTS
		  Else: STMTS
		.
    while_stmt  = Cond: EXPR
		  Body: STMTS
		.
    print_stmt  = Arguments: EXPRS
		.
    read_stmt   = Variable: EXPR
		.
    return_stmt = Value: EXPR  // may be no_expr
		.
  > . // STMT
> . // STMTS

/* list of expressions */
EXPRS = <
  no_exprs	= /* end of list */
		.
  exprs		= Next: EXPRS   REV
		  Expr: EXPR
		.
> .

/* expressions */
EXPR = [Pos: tPosition] <
   no_expr      = // used only in return_stmt
		.
   int_const	= [Value: int]
		.
   float_const	= [Value: double]
		.
   bool_const   = [Value: rbool]
		.
   name         = [Ident: tIdent]         /* variable */
		.
   unary_expr   = [Op     : char]         /* unary expressions */
		  Argument: EXPR
		.
   binary_expr	= [Op  : char]            /* binary expressions */
		  Left : EXPR
		  Right: EXPR
  		.
   cond_expr    = Cond:  EXPR             /* conditional expressions */
		  Then:  EXPR
		  Else:  EXPR
		.
   call_expr    = [Name:     tIdent]      /* function call */
		  Arguments: EXPRS
		.
> .

END abstract_syntax
