/* Project:  COCKTAIL training
 * Descr:    LR parser for an expression language
 * Kind:     Parser specification (stub)
 * Author:   Dr. Juergen Vollmer <Juergen.Vollmer@informatik-vollmer.de>
 * $Id: expr.pars,v 1.4 2007/06/01 12:04:31 vollmer Exp vollmer $
 */

// Exercises:
//  - Add other arithmetic (binary - / **, unary + and -) operations.
//    Think about accosiactivity and operator precedence.
//  - Add identifiers as part of an expression to your grammer
//    extend the scanner.
//  - Add comma separated list of expressions. The list may be empty.
//   'expr_l' (expression list) should be the new grammar root symbol.
//  - Rewrite your grammar, so that precedences are used
//  - Add C-style statements (e.g. assignment, if, while and statement lists)
//    to your grammar. 'stmt' should be the new root symbol of your grammar
//  - Add those statements using Modula-style syntax.
//  - Add more test sources to test your grammar

SCANNER expr_scan

PARSER  expr_pars

GLOBAL {
 # include <stdio.h>
 # include "Tree.h"
}

PREC LEFT  '+' '-'
     LEFT  '*' '/'
     RIGHT '^'
     LEFT  UNARY

RULE
root = l:program
	{=> {TreeRoot = ReverseTree (l:Tree);};}.

program = <
	= i:identifier b:block_scoped
	{tree := mprogram(midentifier(i:Position, i:Value), b:Tree);}.
>.

block_scoped = <
	= 'begin' b:block_exec 'end'
	{tree := mblockscoped(b:Tree);}.
>.

block_exec = <
	= l:block_exec r:statement
	{tree := mblocklist(l:Tree, r:Tree);}.
	= s:statement
	{tree := mblockstmt(s:Tree);}.
>.

statement = <
	= d:declaration ';'
	{tree := mdeclaration(d:Tree);}.
	= a:assignment ';'
	{tree := massignment(a:Tree);}.
	= k:keyword
	{tree := mkeyword(k:Tree);}.
	= .
	{tree := mno_stmt();}
>.

declaration = < 
	= l:type r:identifier
	{tree := mdecl_ident(l:Position, l:Tree, r:Poistion, r:Tree);}.
	= l:type r:assignment.
	{tree := mdecl_assignm(l:Tree, r:Tree);}.
>.

type = <
	= 'int'.
	= 'float'.
	= 'string'.
>.

assignment = <
	= l:identifier '=' r:computation
	{tree := massignment(midentifier(i:Position, i:Value), r:Tree);}.
>.

computation = <
	= l:computation o:'+' r:ttt
	{tree := mcomputation(l:Tree, o:Position, '+', r:Tree);}.
	= computation o:'-' ttt
	{tree := mcomputation(l:Tree, o:Position, '-', r:Tree);}.
	= ttt
	{tree := mcomputation}.
>.

ttt = <
	= l:ttt o:'*' r:fff
	{tree := mcomputation(l:Tree, o:Position, '*', r:Tree);}.
	= l:ttt o:'/' r:fff
	{tree := mcomputation(l:Tree, o:Position, '/', r:Tree);}.
	= fff.
>.

fff = <
	= '(' computation ')'.
	= variable.
>.

variable = <
	= variable_.
	= float_const.
	= '-' variable_ PREC UNARY.
	= '+' variable_ PREC UNARY.
>.

variable_ = <
	= identifier.
	= string_const.
	= int_const.
	= float_const.
>.

keyword = <
	= keyword_if.
	= keyword_while.
	= keyword_for.
>.

keyword_if = <
	= 'if' '(' condition ')' 'then' block_scoped keyword_elseif.
>.

keyword_elseif = <
	= 'elseif' '(' condition ')' 'then' block_scoped keyword_elseif.
	= keyword_else.
>.

keyword_else = <
	= 'else' block_scoped.
	= .
>.

keyword_while = <
	= 'while' '(' condition ')' block_scoped.
>.

keyword_for = <
	= 'for' '(' declaration ';' condition ';' assignment ')' block_scoped.
>.

condition = <
	= computation compare computation.
>.

compare = <
	= '<'.
	= '>'.
	= '='.
	= '!='.
>.

/* Tokens */
string_const: [Value: tIdent] {Value := NoIdent;}.
identifier:   [Ident: tIdent] {Ident := NoIdent;}.
int_const:    [Value: long]   {Value := 0;}.
float_const:  [Value: double] {Value := 0.0;}.

/* non-terminal attributes */
MODULE attributes
PROPERTY SYN
DECLARE
 expr
 expr_l = [tree: tTree].
END attributes
